<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Function Reference</a><ul class="internal"><li><a class="tocitem" href="#General-function"><span>General function</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="function_reference"><a class="docs-heading-anchor" href="#function_reference">Function References</a><a id="function_reference-1"></a><a class="docs-heading-anchor-permalink" href="#function_reference" title="Permalink"></a></h1><ul><li><a href="#function_reference">Function References</a></li><li class="no-marker"><ul><li><a href="#General-function">General function</a></li><li><a href="#Algorithms">Algorithms</a></li><li class="no-marker"><ul><li><a href="#Adaptive-Threshold">Adaptive Threshold</a></li><li><a href="#Niblack">Niblack</a></li><li><a href="#Polysegment">Polysegment</a></li><li><a href="#Sauvola">Sauvola</a></li><li><a href="#Algorithms-that-utilizes-single-histogram-threshold">Algorithms that utilizes single histogram-threshold</a></li></ul></li></ul></li></ul><h2 id="General-function"><a class="docs-heading-anchor" href="#General-function">General function</a><a id="General-function-1"></a><a class="docs-heading-anchor-permalink" href="#General-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.BinarizationAPI.binarize" href="#ImageBinarization.BinarizationAPI.binarize"><code>ImageBinarization.BinarizationAPI.binarize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">binarize([T::Type,] img, f::AbstractImageBinarizationAlgorithm, args...; kwargs...)</code></pre><p>Binarize <code>img</code> using algorithm <code>f</code>.</p><p><strong>Output</strong></p><p>The return image <code>img₀₁</code> is an <code>Array{T}</code>.</p><p>If <code>T</code> is not specified, then it&#39;s inferred as <code>Gray{eltype(eltype(img))}</code>, which is <code>Gray{N0f8}</code> for img of type <code>Array{N0f8}</code> and <code>Array{Gray{N0f8}}</code>, and <code>Gray{Float32}</code> for img of type <code>Array{Float32}</code> and <code>Array{Gray{Float32}}</code></p><p><strong>Examples</strong></p><p>Just simply pass the input image and algorithm to <code>binarize</code></p><pre><code class="language-julia hljs">img₀₁ = binarize(img, f)</code></pre><p>This reads as &quot;<code>binarize</code> image <code>img</code> using binarization algorithm <code>f</code>&quot;.</p><p>You can also explicitly specify the return type:</p><pre><code class="language-julia hljs">img₀₁_float32 = binarize(Gray{Float32}, img, f)</code></pre><p>See also <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> for in-place binarization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/BinarizationAPI/binarize.jl#L113-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.BinarizationAPI.binarize!" href="#ImageBinarization.BinarizationAPI.binarize!"><code>ImageBinarization.BinarizationAPI.binarize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">binarize!([out,] img, f::AbstractImageBinarizationAlgorithm, args...; kwargs...)</code></pre><p>Binarize <code>img</code> using algorithm <code>f</code>.</p><p><strong>Output</strong></p><p>If <code>out</code> is specified, it will be changed in place. Otherwise <code>img</code> will be changed in place.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>binarize!</code>:</p><pre><code class="language-julia hljs">img₀₁ = similar(img)
binarize!(img₀₁, img, f)</code></pre><p>For cases you just want to change <code>img</code> in place, you don&#39;t necessarily need to manually allocate <code>img₀₁</code>; just use the convenient method:</p><pre><code class="language-julia hljs">binarize!(img, f)</code></pre><p>See also: <a href="#ImageBinarization.BinarizationAPI.binarize"><code>binarize</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/BinarizationAPI/binarize.jl#L84-L110">source</a></section></article><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.BinarizationAPI.AbstractImageBinarizationAlgorithm" href="#ImageBinarization.BinarizationAPI.AbstractImageBinarizationAlgorithm"><code>ImageBinarization.BinarizationAPI.AbstractImageBinarizationAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractImageBinarizationAlgorithm &lt;: AbstractImageFilter</code></pre><p>The root type for <code>ImageBinarization</code> package.</p><p>Any concrete binarization algorithm shall subtype it to support <a href="#ImageBinarization.BinarizationAPI.binarize"><code>binarize</code></a> and <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> APIs.</p><p><strong>Examples</strong></p><p>All algorithms in ImageBinarization are called in the following pattern:</p><pre><code class="language-julia hljs"># first generate an algorithm instance
f = Otsu()

# then pass the algorithm to `binarize`
img₀₁ = binarize(img, f) # `eltype(img₀₁)` is `Gray{N0f8}`

# or use in-place version `binarize!`
img₀₁ = similar(img)
binarize!(img₀₁, img, f)</code></pre><p>Some algorithms also receive additional information of image as an argument to infer the &quot;best&quot; parameters, e.g., <code>window_size</code> of <code>AdaptiveThreshold</code>.</p><pre><code class="language-julia hljs"># you could explicit specify the it
f = AdaptiveThreshold(window_size = 32)

# or infer the &quot;best&quot; default value from given image
img = testimage(&quot;cameraman&quot;)
f = AdaptiveThreshold(img)</code></pre><p>For more examples, please check <a href="#ImageBinarization.BinarizationAPI.binarize"><code>binarize</code></a> and <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> and concret algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/BinarizationAPI/binarize.jl#L6-L44">source</a></section></article><h3 id="Adaptive-Threshold"><a class="docs-heading-anchor" href="#Adaptive-Threshold">Adaptive Threshold</a><a id="Adaptive-Threshold-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-Threshold" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.AdaptiveThreshold" href="#ImageBinarization.AdaptiveThreshold"><code>ImageBinarization.AdaptiveThreshold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveThreshold &lt;: AbstractImageBinarizationAlgorithm
AdaptiveThreshold([img]; [window_size,] percentage = 15)

binarize([T,] img, f::AdaptiveThreshold)
binarize!([out,] img, f::AdaptiveThreshold)</code></pre><p>Binarize <code>img</code> using a threshold that varies according to background illumination.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>If the value of a pixel is <code>t</code> percent less than the average of an <span>$s \times s$</span> window of pixels centered around the pixel, then the pixel is set to black, otherwise it is set to white.</p><p>A computationally efficient method for computing the average of an <span>$s \times s$</span> neighbourhood is achieved by using an <em>integral image</em> <code>integral_image</code>.</p><p>This algorithm works particularly well on images that have distinct contrast between background and foreground. See [1] for more details.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that need to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p>You can also pass <code>img</code> to <code>AdaptiveThreshold</code> to automatically infer the &quot;best&quot; <code>window_size</code>.</p><p><strong>Options</strong></p><p>Various options for the parameters of <code>AdaptiveThreshold</code>, <code>binarize</code> and <code>binarize!</code> are described in more detail below.</p><p><strong>Choices for <code>percentage</code></strong></p><p>You can specify an integer for the <code>percentage</code> (denoted by <code>t</code> in [1]) which must be between 0 and 100. Default: 15</p><p><strong>Choices for <code>window_size</code></strong></p><p>The argument <code>window_size</code> (denoted by <code>s</code> in [1]) specifies the size of pixel&#39;s square neighbourhood which must be greater than zero.</p><p>If <code>img</code> is passed to <code>AdaptiveThreshold</code> constructor, then <code>window_size</code> is infered as the integer closest to 1/8 of the average of the width and height of <code>img</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using TestImages

img = testimage(&quot;cameraman&quot;)
f = AdaptiveThreshold(window_size = 16)
img₀₁ = binarize(img, f)

f = AdaptiveThreshold(img) # infer the best `window_size` using `img`
img₀₁ = binarize(img, f)</code></pre><p>See also <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> for in-place operation.</p><p><strong>References</strong></p><p>[1] Bradley, D. (2007). Adaptive Thresholding using Integral Image. <em>Journal of Graphic Tools</em>, 12(2), pp.13-21. <a href="https://doi.org/10.1080/2151237x.2007.10129236">doi:10.1080/2151237x.2007.10129236</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/algorithms/adaptive_threshold.jl#L1-L78">source</a></section></article><h3 id="Niblack"><a class="docs-heading-anchor" href="#Niblack">Niblack</a><a id="Niblack-1"></a><a class="docs-heading-anchor-permalink" href="#Niblack" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.Niblack" href="#ImageBinarization.Niblack"><code>ImageBinarization.Niblack</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Niblack &lt;: AbstractImageBinarizationAlgorithm
Niblack(; window_size = 7, bias = 0.2)

binarize([T,] img, f::Niblack)
binarize!([out,] img, f::Niblack)</code></pre><p>Applies Niblack adaptive thresholding [1] under the assumption that the input image is textual.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>The input image is binarized by varying the threshold across the image, using a modified version of Niblack&#39;s algorithm [2]. A threshold <span>$T$</span> is defined for each pixel based on the mean <span>$m$</span> and standard deviation <span>$s$</span> of the intensities of neighboring pixels in a window around it. This threshold is given by</p><p class="math-container">\[T(x,y) = m(x,y) + k \cdot s(x,y),\]</p><p>where <span>$k$</span> is a user-defined parameter weighting the influence of the standard deviation on the value of <span>$T$</span>.</p><p>Note that Niblack&#39;s algorithm is highly sensitive to variations in the gray values of background pixels, which often exceed local thresholds and appear as artifacts in the binarized image. The <a href="#ImageBinarization.Sauvola"><code>Sauvola</code></a> algorithm included in this package implements an attempt to address this issue [2].</p><p><strong>Arguments</strong></p><p><strong><code>img</code></strong></p><p>An image which is binarized according to a per-pixel adaptive threshold into background (0) and foreground (1) pixel values.</p><p><strong><code>bias::Real</code>  (denoted by <span>$k$</span> in the publication)</strong></p><p>A user-defined biasing parameter on threshold. This can take negative values. Larger <code>bias</code> encourages more black pixels in the output.</p><p><strong><code>window_size::Integer</code> (denoted by <span>$w$</span> in the publication)</strong></p><p>The threshold for each pixel is a function of the distribution of the intensities of all neighboring pixels in a square window around it. The side length of this window is <span>$2w + 1$</span>, with the target pixel in the center position.</p><p>If not specified, <code>window_size</code> is <code>7</code>.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia hljs">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img₀₁ = binarize(img, Niblack())</code></pre><p><strong>References</strong></p><p>[1] Wayne Niblack (1986). <em>An Introduction to Image Processing</em>. Prentice-Hall, Englewood Cliffs, NJ: 115-16. [2] J. Sauvola and M. Pietikäinen (2000). &quot;Adaptive document image binarization&quot;. <em>Pattern Recognition</em> 33 (2): 225-236. <a href="https://doi.org/10.1016/S0031-3203(99)00055-2">doi:10.1016/S0031-3203(99)00055-2</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/algorithms/niblack.jl#L1-L71">source</a></section></article><h3 id="Polysegment"><a class="docs-heading-anchor" href="#Polysegment">Polysegment</a><a id="Polysegment-1"></a><a class="docs-heading-anchor-permalink" href="#Polysegment" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.Polysegment" href="#ImageBinarization.Polysegment"><code>ImageBinarization.Polysegment</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Polysegment &lt;: AbstractImageBinarizationAlgorithm
Polysegment()

binarize([T,] img, f::Polysegment)
binarize!([out,] img, f::Polysegment)</code></pre><p>Uses the <em>polynomial segmentation</em> technique to group the image pixels into two categories (foreground and background).</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>The approach involves constructing a univariate second-degree polynomial such that the two roots of the polynomial represent the graylevels of two cluster centers (i.e the foreground and background). Pixels are then assigned to the foreground or background depending on which cluster center is closest.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code>.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia hljs">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Polysegment())</code></pre><p><strong>Reference</strong></p><ol><li>R. E. Vidal, &quot;Generalized Principal Component Analysis (GPCA): An Algebraic Geometric Approach to Subspace Clustering and Motion Segmentation.&quot; Order No. 3121739, University of California, Berkeley, Ann Arbor, 2003.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/algorithms/polysegment.jl#L1-L48">source</a></section></article><h3 id="Sauvola"><a class="docs-heading-anchor" href="#Sauvola">Sauvola</a><a id="Sauvola-1"></a><a class="docs-heading-anchor-permalink" href="#Sauvola" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.Sauvola" href="#ImageBinarization.Sauvola"><code>ImageBinarization.Sauvola</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Sauvola &lt;: AbstractImageBinarizationAlgorithm
Sauvola(; bias = 0.2, window_size=7)

binarize([T,] img, f::Sauvola)
binarize!([out,] img, f::Sauvola)</code></pre><p>Applies Sauvola–Pietikäinen adaptive image binarization [1] under the assumption that the input image is textual.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>The input image is binarized by varying the threshold across the image, using a modified version of Niblack&#39;s algorithm [2]. Niblack&#39;s approach was to define a threshold <span>$T$</span> for each pixel based on the mean <span>$m$</span> and standard deviation <span>$s$</span> of the intensities of neighboring pixels in a window around it, given by</p><p class="math-container">\[T(x,y) = m(x,y) + k \cdot s(x,y),\]</p><p>where <span>$k$</span> is a user-defined parameter weighting the influence of the standard deviation on the value of <span>$T$</span>.</p><p>Niblack&#39;s algorithm is highly sensitive to variations in the gray values of background pixels, which often exceed local thresholds and appear as artifacts in the binarized image. Sauvola and Pietikäinen [1] introduce the dynamic range <span>$R$</span> of the standard deviation (i.e. its maximum possible value in the color space), such that the threshold is given by</p><p class="math-container">\[T(x,y) = m(x,y) \cdot \left[ 1 + k \cdot \left( \frac{s(x,y)}{R} - 1 \right) \right]\]</p><p>This adaptively amplifies the contribution made by the standard deviation to the value of <span>$T$</span>.</p><p>The Sauvola–Pietikäinen algorithm is implemented here using an optimization proposed by Shafait, Keysers and Breuel [3], in which integral images are used to calculate the values of <span>$m$</span> and <span>$s$</span> for each pixel in constant time. Since each of these data structures can be computed in a single pass over the source image, runtime is significantly improved.</p><p><strong>Arguments</strong></p><p><strong><code>img</code></strong></p><p>An image which is binarized according to a per-pixel adaptive threshold into background (0) and foreground (1) pixel values.</p><p><strong><code>window_size::Integer</code> (denoted by <span>$w$</span> in the publication)</strong></p><p>The threshold for each pixel is a function of the distribution of the intensities of all neighboring pixels in a square window around it. The side length of this window is <span>$2w + 1$</span>, with the target pixel in the center position.</p><p><strong><code>bias::Real</code> (denoted by <span>$k$</span> in the publication)</strong></p><p>A user-defined biasing parameter. This can take negative values, though values in the range [0.2, 0.5] are typical. According to [1], this algorithm is not too sensitive to the value of <span>$k$</span>`.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia hljs">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Sauvola(window_size = 9, bias = 0.2))</code></pre><p><strong>References</strong></p><ol><li>J. Sauvola and M. Pietikäinen (2000). &quot;Adaptive document image binarization&quot;. <em>Pattern Recognition</em> 33 (2): 225-236. <a href="https://doi.org/10.1016/S0031-3203(99)00055-2">doi:10.1016/S0031-3203(99)00055-2</a></li><li>Wayne Niblack (1986). <em>An Introduction to Image Processing</em>. Prentice-Hall, Englewood Cliffs, NJ: 115-16.</li><li>Faisal Shafait, Daniel Keysers and Thomas M. Breuel (2008). &quot;Efficient implementation of local adaptive thresholding techniques using integral images&quot;. Proc. SPIE 6815, Document Recognition and Retrieval XV, 681510 (28 January 2008). <a href="https://doi.org/10.1117/12.767755">doi:10.1117/12.767755</a></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/algorithms/sauvola.jl#L1-L84">source</a></section></article><h3 id="Algorithms-that-utilizes-single-histogram-threshold"><a class="docs-heading-anchor" href="#Algorithms-that-utilizes-single-histogram-threshold">Algorithms that utilizes single histogram-threshold</a><a id="Algorithms-that-utilizes-single-histogram-threshold-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms-that-utilizes-single-histogram-threshold" title="Permalink"></a></h3><p>The core functionality of these algorithms are supported by <a href="https://github.com/JuliaImages/HistogramThresholding.jl">HistogramThresholding.jl</a></p><article class="docstring"><header><a class="docstring-binding" id="ImageBinarization.SingleHistogramThreshold" href="#ImageBinarization.SingleHistogramThreshold"><code>ImageBinarization.SingleHistogramThreshold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleHistogramThreshold &lt;: AbstractImageBinarizationAlgorithm
SingleHistogramThreshold(alg::ThresholdAlgorithm; nbins=256)

binarize([T,] img, f::ThresholdAlgorithm; nbins=256)
binarize!([out,] img, f::ThresholdAlgorithm; nbins=256)</code></pre><p>Binarizes the image <code>img</code> using the threshold found by given threshold finding algorithm <code>alg</code>.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized.  The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong><code>alg::ThresholdAlgorithm</code></strong></p><p><code>ThresholdAlgorithm</code> is an Abstract type defined in <code>ThresholdAlgorithm.jl</code>, it provides various threshold finding algorithms:</p><ul><li><code>HistogramThresholding.Balanced</code></li><li><code>HistogramThresholding.Entropy</code></li><li><code>HistogramThresholding.Intermodes</code></li><li><code>HistogramThresholding.MinimumError</code></li><li><code>HistogramThresholding.MinimumIntermodes</code></li><li><code>HistogramThresholding.Moments</code></li><li><code>HistogramThresholding.Otsu</code></li><li><code>HistogramThresholding.UnimodalRosin</code></li><li><code>HistogramThresholding.Yen</code></li></ul><p>For the more detailed explaination and the construction, please refer to each concrete algorithm. For example, type <code>?Otsu</code> in REPL will give you more details on how to use <code>Otsu</code> methods.</p><p><strong><code>nbins::Integer</code></strong></p><p>The number of discrete bins that used to build the histogram. A smaller <code>nbins</code> could possibly gives a less noisy, or in other words, a smoother output. The default value is <code>256</code>.</p><p><strong>Examples</strong></p><p>All the usage follows the same pattern, take <code>Otsu</code> as an example:</p><pre><code class="language-julia hljs">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Otsu())</code></pre><p>It is less convenient, but still, you could also construct a <code>SingleHistogramThreshold</code> by yourself:</p><pre><code class="language-julia hljs">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
f = SingleHistogramThreshold(Otsu(), nbins=256)
img_binary = binarize(img, f)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/cdd48fd2eacbefb4bfbc80d8b3fa4ebc02456c6c/src/algorithms/single_histogram_threshold.jl#L14-L73">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 1 January 2022 10:47">Saturday 1 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
