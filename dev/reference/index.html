<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function Reference · Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Function Reference</a><ul class="internal"><li><a class="toctext" href="#General-function-1">General function</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function Reference</a></li></ul><a class="edit-page" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="function_reference-1" href="#function_reference-1">Function References</a></h1><ul><li><a href="#function_reference-1">Function References</a></li><ul><li><a href="#General-function-1">General function</a></li><li><a href="#Algorithms-1">Algorithms</a></li><ul><li><a href="#Adaptive-Threshold-1">Adaptive Threshold</a></li><li><a href="#Balanced-1">Balanced</a></li><li><a href="#Entropy-1">Entropy</a></li><li><a href="#Intermodes-1">Intermodes</a></li><li><a href="#Minimum-Error-1">Minimum Error</a></li><li><a href="#Minimum-Intermodes-1">Minimum Intermodes</a></li><li><a href="#Moments-1">Moments</a></li><li><a href="#Niblack-1">Niblack</a></li><li><a href="#Otsu-1">Otsu</a></li><li><a href="#Polysegment-1">Polysegment</a></li><li><a href="#Sauvola-1">Sauvola</a></li><li><a href="#Unimodal-Rosin-1">Unimodal Rosin</a></li><li><a href="#Yen-1">Yen</a></li></ul></ul></ul><h2><a class="nav-anchor" id="General-function-1" href="#General-function-1">General function</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.BinarizationAPI.binarize" href="#ImageBinarization.BinarizationAPI.binarize"><code>ImageBinarization.BinarizationAPI.binarize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">binarize([T::Type,] img, f::AbstractImageBinarizationAlgorithm, args...; kwargs...)</code></pre><p>Binarize <code>img</code> using algorithm <code>f</code>.</p><p><strong>Output</strong></p><p>The return image <code>img₀₁</code> is an <code>Array{T}</code>.</p><p>If <code>T</code> is not specified, then it&#39;s inferred as <code>Gray{eltype(eltype(img))}</code>, which is <code>Gray{N0f8}</code> for img of type <code>Array{N0f8}</code> and <code>Array{Gray{N0f8}}</code>, and <code>Gray{Float32}</code> for img of type <code>Array{Float32}</code> and <code>Array{Gray{Float32}}</code></p><p><strong>Examples</strong></p><p>Just simply pass the input image and algorithm to <code>binarize</code></p><pre><code class="language-julia">img₀₁ = binarize(img, f)</code></pre><p>This reads as &quot;<code>binarize</code> image <code>img</code> using binarization algorithm <code>f</code>&quot;.</p><p>You can also explicitly specify the return type:</p><pre><code class="language-julia">img₀₁_float32 = binarize(Gray{Float32}, img, f)</code></pre><p>See also <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> for in-place binarization.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/BinarizationAPI/binarize.jl#L107-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.BinarizationAPI.binarize!" href="#ImageBinarization.BinarizationAPI.binarize!"><code>ImageBinarization.BinarizationAPI.binarize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">binarize!([out,] img, f::AbstractImageBinarizationAlgorithm, args...; kwargs...)</code></pre><p>Binarize <code>img</code> using algorithm <code>f</code>.</p><p><strong>Output</strong></p><p>If <code>out</code> is specified, it will be changed in place. Otherwise <code>img</code> will be changed in place.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>binarize!</code>:</p><pre><code class="language-julia">img₀₁ = similar(img)
binarize!(img₀₁, img, f)</code></pre><p>For cases you just want to change <code>img</code> in place, you don&#39;t necessarily need to manually allocate <code>img₀₁</code>; just use the convenient method:</p><pre><code class="language-julia">binarize!(img, f)</code></pre><p>See also: <a href="#ImageBinarization.BinarizationAPI.binarize"><code>binarize</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/BinarizationAPI/binarize.jl#L78-L104">source</a></section><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.BinarizationAPI.AbstractImageBinarizationAlgorithm" href="#ImageBinarization.BinarizationAPI.AbstractImageBinarizationAlgorithm"><code>ImageBinarization.BinarizationAPI.AbstractImageBinarizationAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractImageBinarizationAlgorithm &lt;: AbstractImageFilter</code></pre><p>The root type for <code>ImageBinarization</code> package.</p><p>Any concrete binarization algorithm shall subtype it to support <a href="#ImageBinarization.BinarizationAPI.binarize"><code>binarize</code></a> and <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> APIs.</p><p><strong>Examples</strong></p><p>All algorithms in ImageBinarization are called in the following pattern:</p><pre><code class="language-julia"># first generate an algorithm instance
f = Otsu()

# then pass the algorithm to `binarize`
img₀₁ = binarize(img, f) # `eltype(img₀₁)` is `Gray{N0f8}`

# or use in-place version `binarize!`
img₀₁ = similar(img)
binarize!(img₀₁, img, f)</code></pre><p>Some algorithms also receive additional information of image as an argument to infer the &quot;best&quot; parameters, e.g., <code>window_size</code> of <code>AdaptiveThreshold</code>.</p><pre><code class="language-julia"># you could explicit specify the it
f = AdaptiveThreshold(window_size = 32)

# or infer the &quot;best&quot; default value from given image
img = testimage(&quot;cameraman&quot;)
f = AdaptiveThreshold(img)</code></pre><p>For more examples, please check <a href="#ImageBinarization.BinarizationAPI.binarize"><code>binarize</code></a> and <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> and concret algorithms.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/BinarizationAPI/binarize.jl#L6-L44">source</a></section><h3><a class="nav-anchor" id="Adaptive-Threshold-1" href="#Adaptive-Threshold-1">Adaptive Threshold</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.AdaptiveThreshold" href="#ImageBinarization.AdaptiveThreshold"><code>ImageBinarization.AdaptiveThreshold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AdaptiveThreshold &lt;: AbstractImageBinarizationAlgorithm
AdaptiveThreshold([img]; [window_size,] percentage = 15)

binarize([T,] img, f::AdaptiveThreshold)
binarize!([out,] img, f::AdaptiveThreshold)</code></pre><p>Binarize <code>img</code> using a threshold that varies according to background illumination.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>If the value of a pixel is <code>t</code> percent less than the average of an <span>$s \times s$</span> window of pixels centered around the pixel, then the pixel is set to black, otherwise it is set to white.</p><p>A computationally efficient method for computing the average of an <span>$s \times s$</span> neighbourhood is achieved by using an <em>integral image</em> <code>integral_image</code>.</p><p>This algorithm works particularly well on images that have distinct contrast between background and foreground. See [1] for more details.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that need to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p>You can also pass <code>img</code> to <code>AdaptiveThreshold</code> to automatically infer the &quot;best&quot; <code>window_size</code>.</p><p><strong>Options</strong></p><p>Various options for the parameters of <code>AdaptiveThreshold</code>, <code>binarize</code> and <code>binarize!</code> are described in more detail below.</p><p><strong>Choices for <code>percentage</code></strong></p><p>You can specify an integer for the <code>percentage</code> (denoted by <code>t</code> in [1]) which must be between 0 and 100. Default: 15</p><p><strong>Choices for <code>window_size</code></strong></p><p>The argument <code>window_size</code> (denoted by <code>s</code> in [1]) specifies the size of pixel&#39;s square neighbourhood which must be greater than zero.</p><p>If <code>img</code> is passed to <code>AdaptiveThreshold</code> constructor, then <code>window_size</code> is infered as the integer closest to 1/8 of the average of the width and height of <code>img</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">using TestImages

img = testimage(&quot;cameraman&quot;)
f = AdaptiveThreshold(window_size = 16)
img₀₁ = binarize(img, f)

f = AdaptiveThreshold(img) # infer the best `window_size` using `img`
img₀₁ = binarize(img, f)</code></pre><p>See also <a href="#ImageBinarization.BinarizationAPI.binarize!"><code>binarize!</code></a> for in-place operation.</p><p><strong>References</strong></p><p>[1] Bradley, D. (2007). Adaptive Thresholding using Integral Image. <em>Journal of Graphic Tools</em>, 12(2), pp.13-21. <a href="https://doi.org/10.1080/2151237x.2007.10129236">doi:10.1080/2151237x.2007.10129236</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/adaptive_threshold.jl#L1-L78">source</a></section><h3><a class="nav-anchor" id="Balanced-1" href="#Balanced-1">Balanced</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Balanced" href="#ImageBinarization.Balanced"><code>ImageBinarization.Balanced</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Balanced &lt;: AbstractImageBinarizationAlgorithm
Balanced()

binarize([T,] img, f::Balanced)
binarize!([out,] img, f::Balanced)</code></pre><p>Binarizes the image using the balanced histogram thresholding method.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>In balanced histogram thresholding, one interprets a bin as a physical weight with a mass equal to its occupancy count. The balanced histogram method involves iterating the following three steps: (1) choose the midpoint bin index as a &quot;pivot&quot;,  (2) compute the combined weight to the left and right of the pivot bin and (3) remove the leftmost bin if the left side is the heaviest, and the rightmost bin otherwise. The algorithm stops when only a single bin remains. The last bin determines the sought-after threshold with which the image is binarized.</p><p>Let <span>$f_n$</span> (<span>$n = 1 \ldots N$</span>) denote the number of observations in the <span>$n$</span>th bin of the image histogram. The balanced histogram method constructs a sequence of nested intervals</p><div>\[[1,N] \cap \mathbb{Z} \supset I_2 \supset I_3 \supset \ldots \supset I_{N-1},\]</div><p>where for <span>$k = 2 \ldots N-1$</span></p><div>\[I_k = \begin{cases}
   I_{k-1} \setminus \{\min \left( I_{k-1} \right) \} &amp;\text{if } \sum_{n = \min \left( I_{k-1} \right)}^{I_m}f_n \gt   \sum_{n =  I_m + 1}^{ \max \left( I_{k-1} \right)} f_n, \\
   I_{k-1} \setminus \{\max \left( I_{k-1} \right) \} &amp;\text{otherwise},
\end{cases}\]</div><p>and <span>$I_m = \lfloor \frac{1}{2}\left(  \min \left( I_{k-1} \right) +  \max \left( I_{k-1} \right) \right) \rfloor$</span>. The final interval <span>$I_{N-1}$</span> consists of a single element which is the bin index corresponding to the desired threshold.</p><p>If one interprets a bin as a physical weight with a mass equal to its occupancy count, then each step of the algorithm can be conceptualised as removing the leftmost or rightmost bin to &quot;balance&quot; the resulting histogram on a pivot. The pivot is defined to be the midpoint between the start and end points of the interval under consideration.</p><p>If it turns out that the single element in <span>$I_{N-1}$</span> equals <span>$1$</span> or <span>$N$</span> then the original histogram must have a single peak and the algorithm has failed to find a suitable threshold. In this case the algorithm will fall back to using the <code>UnimodalRosin</code> method to select the threshold.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Balanced())</code></pre><p><strong>Reference</strong></p><ol><li>“BI-LEVEL IMAGE THRESHOLDING - A Fast Method”, Proceedings of the First International Conference on Bio-inspired Systems and Signal Processing, 2008. Available: <a href="https://doi.org/10.5220/0001064300700076">10.5220/0001064300700076</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/balanced.jl#L1-L80">source</a></section><h3><a class="nav-anchor" id="Entropy-1" href="#Entropy-1">Entropy</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Entropy" href="#ImageBinarization.Entropy"><code>ImageBinarization.Entropy</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Entropy &lt;: AbstractImageBinarizationAlgorithm
Entropy()

binarize([T,] img, f::Entropy)
binarize!([out,] img, f::Entropy)</code></pre><p>An algorithm for finding the binarization threshold value using the entropy of the image histogram.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>This algorithm uses the entropy of a one-dimensional histogram to produce a threshold value.</p><p>Let <span>$f_1, f_2, \ldots, f_I$</span> be the frequencies in the various bins of the histogram and <span>$I$</span> the number of bins. With <span>$N = \sum_{i=1}^{I}f_i$</span>, let <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>) denote the probability distribution of gray levels. From this distribution one derives two additional distributions. The first defined for discrete values <span>$1$</span> to <span>$s$</span> and the other, from <span>$s+1$</span> to <span>$I$</span>. These distributions are</p><div>\[A: \frac{p_1}{P_s}, \frac{p_2}{P_s}, \ldots, \frac{p_s}{P_s}
\quad \text{and} \quad
B: \frac{p_{s+1}}{1-P_s}, \ldots, \frac{p_n}{1-P_s}
\quad \text{where} \quad
P_s = \sum_{i=1}^{s}p_i.\]</div><p>The entropies associated with each distribution are as follows:</p><div>\[H(A) = \ln(P_s) + \frac{H_s}{P_s}\]</div><div>\[H(B) = \ln(1-P_s) + \frac{H_n-H_s}{1-P_s}\]</div><div>\[\quad \text{where} \quad
H_s = -\sum_{i=1}^{s}p_i\ln{p_i}
\quad \text{and} \quad
H_n = -\sum_{i=1}^{I}p_i\ln{p_i}.\]</div><p>Combining these two entropy functions we have</p><div>\[\psi(s) = \ln(P_s(1-P_s)) + \frac{H_s}{P_s} + \frac{H_n-H_s}{1-P_s}.\]</div><p>Finding the discrete value <span>$s$</span> which maximises the function <span>$\psi(s)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold).</p><p>See Section 4 of [1] for more details on the derivation of the entropy.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Entropy())</code></pre><p><strong>References</strong></p><ol><li>J. N. Kapur, P. K. Sahoo, and A. K. C. Wong, “A new method for gray-level picture thresholding using the entropy of the histogram,” <em>Computer Vision, Graphics, and Image Processing</em>, vol. 29, no. 1, p. 140, Jan. 1985.<a href="https://doi.org/10.1016/s0734-189x%2885%2990156-2">doi:10.1016/s0734-189x(85)90156-2</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/entropy.jl#L1-L83">source</a></section><h3><a class="nav-anchor" id="Intermodes-1" href="#Intermodes-1">Intermodes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Intermodes" href="#ImageBinarization.Intermodes"><code>ImageBinarization.Intermodes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Intermodes &lt;: AbstractImageBinarizationAlgorithm
Intermodes()

binarize([T,] img, f::AdaptiveThreshold; [window_size])
binarize!([out,] img, f::AdaptiveThreshold; [window_size])</code></pre><p>Under the assumption that the image histogram is bimodal the image histogram is smoothed using a length-3 mean filter until two modes remain. The binarization threshold is then set to the average value of the two modes.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Intermodes())</code></pre><p><strong>Reference</strong></p><ol><li>C. A. Glasbey, “An Analysis of Histogram-Based Thresholding Algorithms,” CVGIP: Graphical Models and Image Processing, vol. 55, no. 6, pp. 532–537, Nov. 1993. <a href="https://doi.org/10.1006/cgip.1993.1040">doi:10.1006/cgip.1993.1040</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/intermodes.jl#L1-L41">source</a></section><h3><a class="nav-anchor" id="Minimum-Error-1" href="#Minimum-Error-1">Minimum Error</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.MinimumError" href="#ImageBinarization.MinimumError"><code>ImageBinarization.MinimumError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinimumError &lt;: AbstractImageBinarizationAlgorithm
MinimumError()

binarize([T,] img, f::MinimumError)
binarize!([out,] img, f::MinimumError)</code></pre><p>Under the assumption that the image histogram is a mixture of two Gaussian distributions the binarization threshold is chosen such that the expected misclassification error rate is minimised.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>Let <span>$f_i$</span> <span>$(i=1 \ldots I)$</span> denote the number of observations in the <span>$i$</span>th bin of the histogram. Then the probability that an observation belongs to the <span>$i$</span>th bin is given by  <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>), where <span>$N = \sum_{i=1}^{I}f_i$</span>.</p><p>The minimum error thresholding method assumes that one can find a threshold <span>$T$</span> which partitions the data into two categories,  <span>$C_0$</span> and <span>$C_1$</span>, such that the data can be modelled by a mixture of two Gaussian distribution. Let</p><div>\[P_0(T) = \sum_{i = 1}^T p_i \quad \text{and} \quad P_1(T) = \sum_{i = T+1}^I p_i\]</div><p>denote the cumulative probabilities,</p><div>\[\mu_0(T) = \sum_{i = 1}^T i \frac{p_i}{P_0(T)} \quad \text{and} \quad \mu_1(T) = \sum_{i = T+1}^I i \frac{p_i}{P_1(T)}\]</div><p>denote the means, and</p><div>\[\sigma_0^2(T) = \sum_{i = 1}^T (i-\mu_0(T))^2 \frac{p_i}{P_0(T)} \quad \text{and} \quad \sigma_1^2(T) = \sum_{i = T+1}^I (i-\mu_1(T))^2 \frac{p_i}{P_1(T)}\]</div><p>denote the variances of categories <span>$C_0$</span> and <span>$C_1$</span>, respectively.</p><p>Kittler and Illingworth proposed to use the minimum error criterion function</p><div>\[J(T) = 1 + 2 \left[ P_0(T) \ln \sigma_0(T) + P_1(T) \ln \sigma_1(T) \right] - 2 \left[P_0(T) \ln P_0(T) + P_1(T) \ln P_1(T) \right]\]</div><p>to assess the discreprancy between the mixture of Gaussians implied by a particular threshold <span>$T$</span>, and the piecewise-constant probability density function represented by the histogram. The discrete value <span>$T$</span> which minimizes the function <span>$J(T)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold).</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, MinimumError())</code></pre><p><strong>References</strong></p><ol><li>J. Kittler and J. Illingworth, “Minimum error thresholding,” Pattern Recognition, vol. 19, no. 1, pp. 41–47, Jan. 1986. <a href="https://doi.org/10.1016/0031-3203%2886%2990030-0">doi:10.1016/0031-3203(86)90030-0</a></li><li>Q.-Z. Ye and P.-E. Danielsson, “On minimum error thresholding and its implementations,” Pattern Recognition Letters, vol. 7, no. 4, pp. 201–206, Apr. 1988. <a href="https://doi.org/10.1016/0167-8655%2888%2990103-1">doi:10.1016/0167-8655(88)90103-1</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/minimum_error.jl#L1-L73">source</a></section><h3><a class="nav-anchor" id="Minimum-Intermodes-1" href="#Minimum-Intermodes-1">Minimum Intermodes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.MinimumIntermodes" href="#ImageBinarization.MinimumIntermodes"><code>ImageBinarization.MinimumIntermodes</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MinimumIntermodes &lt;: AbstractImageBinarizationAlgorithm
MinimumIntermodes()

binarize([T,] img, f::MinimumIntermodes)
binarize!([out,] img, f::MinimumIntermodes)</code></pre><p>Under the assumption that the image histogram is bimodal the histogram is smoothed using a length-3 mean filter until two modes remain. The binarization threshold is then set to the minimum value between the two modes.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, MinimumIntermodes())</code></pre><p><strong>Reference</strong></p><ol><li>C. A. Glasbey, “An Analysis of Histogram-Based Thresholding Algorithms,” <em>CVGIP: Graphical Models and Image Processing</em>, vol. 55, no. 6, pp. 532–537, Nov. 1993. <a href="https://doi.org/10.1006/cgip.1993.1040">doi:10.1006/cgip.1993.1040</a></li><li>J. M. S. Prewitt and M. L. Mendelsohn, “THE ANALYSIS OF CELL IMAGES<em>,” *Annals of the New York Academy of Sciences</em>, vol. 128, no. 3, pp. 1035–1053, Dec. 2006. <a href="https://doi.org/10.1111/j.1749-6632.1965.tb11715.x">doi:10.1111/j.1749-6632.1965.tb11715.x</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/minimum.jl#L1-L41">source</a></section><h3><a class="nav-anchor" id="Moments-1" href="#Moments-1">Moments</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Moments" href="#ImageBinarization.Moments"><code>ImageBinarization.Moments</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Moments &lt;: AbstractImageBinarizationAlgorithm
Moments()

binarize([T,] img, f::Moments)
binarize!([out,] img, f::Moments)</code></pre><p>The following rule determines the binarization threshold:  if one assigns all observations below the threshold to a value z₀ and all observations above the threshold to a value z₁, then the first three moments of the original histogram must match the moments of this specially constructed bilevel histogram.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>Let <span>$f_i$</span> <span>$(i=1 \ldots I)$</span> denote the number of observations in the <span>$i$</span>th bin of the histogram and <span>$z_i$</span> <span>$(i=1 \ldots I)$</span> the observed value associated with the <span>$i$</span>th bin.  Then the probability that an observation <span>$z_i$</span> belongs to the <span>$i$</span>th bin is given by  <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>), where <span>$N = \sum_{i=1}^{I}f_i$</span>.</p><p>Moments can be computed from the histogram <span>$f$</span> in the following way:</p><div>\[m_k = \frac{1}{N} \sum_i p_i (z_i)^k \quad k = 0,1,2,3, \ldots.\]</div><p>The principle of moment-preserving thresholding is to select a threshold value, as well as two representative values <span>$z_0$</span> and <span>$z_1$</span> (<span>$z_0 &lt; z_1$</span>), such that if all below-threshold values in <span>$f$</span> are replaced by <span>$z_0$</span> and all above-threshold values are replaced by <span>$z_1$</span>, then this specially constructed bilevel histogram <span>$g$</span> will have the same first three moments as <span>$f$</span>.</p><p>Concretely, let <span>$q_0$</span> and <span>$q_1$</span> denote the fractions of observations below and above the threshold in <span>$f$</span>, respectively. The constraint that the first three moments in <span>$g$</span> must equal the first three moments in <span>$f$</span> can be expressed by the following system of four equations</p><div>\[\begin{aligned}
   q_0 (z_0)^0 + q_1 (z_1)^0   &amp; = m_0 \\
   q_0 (z_0)^1 + q_1 (z_1)^1   &amp; = m_1 \\
   q_0 (z_0)^2 + q_1 (z_1)^2   &amp; = m_2 \\
   q_0 (z_0)^3 + q_1 (z_1)^3   &amp; = m_3 \\
\end{aligned}\]</div><p>where the left-hand side represents the moments of <span>$g$</span> and the right-hand side represents the moments of <span>$f$</span>. To find the desired treshold value, one first solves the four equations to obtain <span>$q_0$</span> and <span>$q_1$</span>, and then chooses the threshold <span>$t$</span> such that <span>$q_0 = \sum_{z_i \le t} p_i$</span>.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Moments())</code></pre><p><strong>Reference</strong></p><p>[1] W.-H. Tsai, “Moment-preserving thresolding: A new approach,” Computer Vision, Graphics, and Image Processing, vol. 29, no. 3, pp. 377–393, Mar. 1985. <a href="https://doi.org/10.1016/0734-189x%2885%2990133-1">doi:10.1016/0734-189x(85)90133-1</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/moments.jl#L1-L80">source</a></section><h3><a class="nav-anchor" id="Niblack-1" href="#Niblack-1">Niblack</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Niblack" href="#ImageBinarization.Niblack"><code>ImageBinarization.Niblack</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Niblack &lt;: AbstractImageBinarizationAlgorithm
Niblack(; window_size = 7, bias = 0.2)

binarize([T,] img, f::Niblack)
binarize!([out,] img, f::Niblack)</code></pre><p>Applies Niblack adaptive thresholding [1] under the assumption that the input image is textual.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>The input image is binarized by varying the threshold across the image, using a modified version of Niblack&#39;s algorithm [2]. A threshold <span>$T$</span> is defined for each pixel based on the mean <span>$m$</span> and standard deviation <span>$s$</span> of the intensities of neighboring pixels in a window around it. This threshold is given by</p><div>\[T(x,y) = m(x,y) + k \cdot s(x,y),\]</div><p>where <span>$k$</span> is a user-defined parameter weighting the influence of the standard deviation on the value of <span>$T$</span>.</p><p>Note that Niblack&#39;s algorithm is highly sensitive to variations in the gray values of background pixels, which often exceed local thresholds and appear as artifacts in the binarized image. The <a href="#ImageBinarization.Sauvola"><code>Sauvola</code></a> algorithm included in this package implements an attempt to address this issue [2].</p><p><strong>Arguments</strong></p><p><strong><code>img</code></strong></p><p>An image which is binarized according to a per-pixel adaptive threshold into background (0) and foreground (1) pixel values.</p><p><strong><code>bias::Real</code>  (denoted by <span>$k$</span> in the publication)</strong></p><p>A user-defined biasing parameter on threshold. This can take negative values. Larger <code>bias</code> encourages more black pixels in the output.</p><p><strong><code>window_size::Integer</code> (denoted by <span>$w$</span> in the publication)</strong></p><p>The threshold for each pixel is a function of the distribution of the intensities of all neighboring pixels in a square window around it. The side length of this window is <span>$2w + 1$</span>, with the target pixel in the center position.</p><p>If not specified, <code>window_size</code> is <code>7</code>.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img₀₁ = binarize(img, Niblack())</code></pre><p><strong>References</strong></p><p>[1] Wayne Niblack (1986). <em>An Introduction to Image Processing</em>. Prentice-Hall, Englewood Cliffs, NJ: 115-16. [2] J. Sauvola and M. Pietikäinen (2000). &quot;Adaptive document image binarization&quot;. <em>Pattern Recognition</em> 33 (2): 225-236. <a href="https://doi.org/10.1016/S0031-3203(99)00055-2">doi:10.1016/S0031-3203(99)00055-2</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/niblack.jl#L1-L71">source</a></section><h3><a class="nav-anchor" id="Otsu-1" href="#Otsu-1">Otsu</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Otsu" href="#ImageBinarization.Otsu"><code>ImageBinarization.Otsu</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Otsu &lt;: AbstractImageBinarizationAlgorithm
Otsu()

binarize([T,] img, f::Otsu)
binarize!([out,] img, f::Otsu)</code></pre><p>Under the assumption that the image histogram is bimodal the binarization threshold is set so that the resultant between-class variance is maximal.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>Let <span>$f_i$</span> <span>$(i=1 \ldots I)$</span> denote the number of observations in the <span>$i$</span>th bin of the image histogram. Then the probability that an observation belongs to the <span>$i$</span>th bin is given by  <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>), where <span>$N = \sum_{i=1}^{I}f_i$</span>.</p><p>The choice of a threshold <span>$T$</span> partitions the data into two categories, <span>$C_0$</span> and <span>$C_1$</span>. Let</p><div>\[P_0(T) = \sum_{i = 1}^T p_i \quad \text{and} \quad P_1(T) = \sum_{i = T+1}^I p_i\]</div><p>denote the cumulative probabilities,</p><div>\[\mu_0(T) = \sum_{i = 1}^T i \frac{p_i}{P_0(T)} \quad \text{and} \quad \mu_1(T) = \sum_{i = T+1}^I i \frac{p_i}{P_1(T)}\]</div><p>denote the means, and</p><div>\[\sigma_0^2(T) = \sum_{i = 1}^T (i-\mu_0(T))^2 \frac{p_i}{P_0(T)} \quad \text{and} \quad \sigma_1^2(T) = \sum_{i = T+1}^I (i-\mu_1(T))^2 \frac{p_i}{P_1(T)}\]</div><p>denote the variances of categories <span>$C_0$</span> and <span>$C_1$</span>, respectively. Furthermore, let</p><div>\[\mu = P_0(T)\mu_0(T) + P_1(T)\mu_1(T),\]</div><p>represent the overall mean,</p><div>\[\sigma_b^2(T) = P_0(T)(\mu_0(T) - \mu)^2 + P_1(T)(\mu_1(T) - \mu)^2,\]</div><p>the between-category variance, and</p><div>\[\sigma_w^2(T) = P_0(T) \sigma_0^2(T) +  P_1(T)\sigma_1^2(T)\]</div><p>the within-category variance, respectively.</p><p>Finding the discrete value <span>$T$</span> which maximises the function <span>$\sigma_b^2(T)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold). As it turns out, that threshold value is equal to the threshold decided by minimizing the within-category variances criterion <span>$\sigma_w^2(T)$</span>. Furthermore, that threshold is also the same as the threshold calculated by maximizing the ratio of between-category variance to within-category variance.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized.  The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Otsu())</code></pre><p><strong>Reference</strong></p><ol><li>Nobuyuki Otsu (1979). “A threshold selection method from gray-level histograms”. <em>IEEE Trans. Sys., Man., Cyber.</em> 9 (1): 62–66. <a href="http://dx.doi.org/doi:10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/otsu.jl#L1-L82">source</a></section><h3><a class="nav-anchor" id="Polysegment-1" href="#Polysegment-1">Polysegment</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Polysegment" href="#ImageBinarization.Polysegment"><code>ImageBinarization.Polysegment</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Polysegment &lt;: AbstractImageBinarizationAlgorithm
Polysegment()

binarize([T,] img, f::Polysegment)
binarize!([out,] img, f::Polysegment)</code></pre><p>Uses the <em>polynomial segmentation</em> technique to group the image pixels into two categories (foreground and background).</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>The approach involves constructing a univariate second-degree polynomial such that the two roots of the polynomial represent the graylevels of two cluster centers (i.e the foreground and background). Pixels are then assigned to the foreground or background depending on which cluster center is closest.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code>.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Polysegment())</code></pre><p><strong>Reference</strong></p><ol><li>R. E. Vidal, &quot;Generalized Principal Component Analysis (GPCA): An Algebraic Geometric Approach to Subspace Clustering and Motion Segmentation.&quot; Order No. 3121739, University of California, Berkeley, Ann Arbor, 2003.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/polysegment.jl#L1-L48">source</a></section><h3><a class="nav-anchor" id="Sauvola-1" href="#Sauvola-1">Sauvola</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Sauvola" href="#ImageBinarization.Sauvola"><code>ImageBinarization.Sauvola</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Sauvola &lt;: AbstractImageBinarizationAlgorithm
Sauvola(; bias = 0.2, window_size=7)

binarize([T,] img, f::Sauvola)
binarize!([out,] img, f::Sauvola)</code></pre><p>Applies Sauvola–Pietikäinen adaptive image binarization [1] under the assumption that the input image is textual.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>The input image is binarized by varying the threshold across the image, using a modified version of Niblack&#39;s algorithm [2]. Niblack&#39;s approach was to define a threshold <span>$T$</span> for each pixel based on the mean <span>$m$</span> and standard deviation <span>$s$</span> of the intensities of neighboring pixels in a window around it, given by</p><div>\[T(x,y) = m(x,y) + k \cdot s(x,y),\]</div><p>where <span>$k$</span> is a user-defined parameter weighting the influence of the standard deviation on the value of <span>$T$</span>.</p><p>Niblack&#39;s algorithm is highly sensitive to variations in the gray values of background pixels, which often exceed local thresholds and appear as artifacts in the binarized image. Sauvola and Pietikäinen [1] introduce the dynamic range <span>$R$</span> of the standard deviation (i.e. its maximum possible value in the color space), such that the threshold is given by</p><div>\[T(x,y) = m(x,y) \cdot \left[ 1 + k \cdot \left( \frac{s(x,y)}{R} - 1 \right) \right]\]</div><p>This adaptively amplifies the contribution made by the standard deviation to the value of <span>$T$</span>.</p><p>The Sauvola–Pietikäinen algorithm is implemented here using an optimization proposed by Shafait, Keysers and Breuel [3], in which integral images are used to calculate the values of <span>$m$</span> and <span>$s$</span> for each pixel in constant time. Since each of these data structures can be computed in a single pass over the source image, runtime is significantly improved.</p><p><strong>Arguments</strong></p><p><strong><code>img</code></strong></p><p>An image which is binarized according to a per-pixel adaptive threshold into background (0) and foreground (1) pixel values.</p><p><strong><code>window_size::Integer</code> (denoted by <span>$w$</span> in the publication)</strong></p><p>The threshold for each pixel is a function of the distribution of the intensities of all neighboring pixels in a square window around it. The side length of this window is <span>$2w + 1$</span>, with the target pixel in the center position.</p><p><strong><code>bias::Real</code> (denoted by <span>$k$</span> in the publication)</strong></p><p>A user-defined biasing parameter. This can take negative values, though values in the range [0.2, 0.5] are typical. According to [1], this algorithm is not too sensitive to the value of <span>$k$</span>`.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Sauvola(window_size = 9, bias = 0.2))</code></pre><p><strong>References</strong></p><ol><li>J. Sauvola and M. Pietikäinen (2000). &quot;Adaptive document image binarization&quot;. <em>Pattern Recognition</em> 33 (2): 225-236. <a href="https://doi.org/10.1016/S0031-3203(99)00055-2">doi:10.1016/S0031-3203(99)00055-2</a></li><li>Wayne Niblack (1986). <em>An Introduction to Image Processing</em>. Prentice-Hall, Englewood Cliffs, NJ: 115-16.</li><li>Faisal Shafait, Daniel Keysers and Thomas M. Breuel (2008). &quot;Efficient implementation of local adaptive thresholding techniques using integral images&quot;. Proc. SPIE 6815, Document Recognition and Retrieval XV, 681510 (28 January 2008). <a href="https://doi.org/10.1117/12.767755">doi:10.1117/12.767755</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/sauvola.jl#L1-L84">source</a></section><h3><a class="nav-anchor" id="Unimodal-Rosin-1" href="#Unimodal-Rosin-1">Unimodal Rosin</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.UnimodalRosin" href="#ImageBinarization.UnimodalRosin"><code>ImageBinarization.UnimodalRosin</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">UnimodalRosin &lt;: AbstractImageBinarizationAlgorithm
UnimodalRosin()

binarize([T,] img, f::UnimodalRosin)
binarize!([out,] img, f::UnimodalRosin)</code></pre><p>Uses Rosin&#39;s Unimodal threshold algorithm to binarize the image.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>This algorithm first selects the bin in the image histogram with the highest frequency. The algorithm then searches from the location of the maximum bin to the last bin of the histogram for the first bin with a frequency of 0 (known as the minimum bin.). A line is then drawn that passes through both the maximum and minimum bins. The bin with the greatest orthogonal distance to the line is chosen as the threshold value.</p><p><strong>Assumptions</strong></p><p>This algorithm assumes that:</p><ul><li>The histogram is unimodal.</li><li>There is always at least one bin that has a frequency of 0. If not, the algorithm will use the last bin as the minimum bin.</li></ul><p>If the histogram includes multiple bins with a frequency of 0, the algorithm will select the first zero bin as its minimum. If there are multiple bins with the greatest orthogonal distance, the leftmost bin is selected as the threshold.</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Compute the threshold for the &quot;moonsurface&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;moonsurface&quot;)
img_binary = binarize(img, UnimodalRosin())</code></pre><p><strong>Reference</strong></p><ol><li>P. L. Rosin, “Unimodal thresholding,” Pattern Recognition, vol. 34, no. 11, pp. 2083–2096, Nov. 2001.<a href="https://doi.org/10.1016/s0031-3203%2800%2900136-9">doi:10.1016/s0031-3203(00)00136-9</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/unimodal.jl#L1-L60">source</a></section><h3><a class="nav-anchor" id="Yen-1" href="#Yen-1">Yen</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.Yen" href="#ImageBinarization.Yen"><code>ImageBinarization.Yen</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Yen &lt;: AbstractImageBinarizationAlgorithm
Yen()

binarize([T,] img, f::Yen)
binarize!([out,] img, f::Yen)</code></pre><p>Computes the binarization threshold value using Yen&#39;s maximum correlation criterion for bilevel thresholding.</p><p><strong>Output</strong></p><p>Return the binarized image as an <code>Array{Gray{T}}</code> of size <code>size(img)</code>. If <code>T</code> is not specified, it is inferred from <code>out</code> and <code>img</code>.</p><p><strong>Details</strong></p><p>This algorithm uses the concept of <em>entropic correlation</em> of a gray level histogram to produce a threshold value.</p><p>Let <span>$f_1, f_2, \ldots, f_I$</span> be the frequencies in the various bins of the histogram and <span>$I$</span> the number of bins. With <span>$N = \sum_{i=1}^{I}f_i$</span>, let <span>$p_i = \frac{f_i}{N}$</span> (<span>$i = 1, \ldots, I$</span>) denote the probability distribution of gray levels. From this distribution one derives two additional distributions. The first defined for discrete values <span>$1$</span> to <span>$s$</span> and the other, from <span>$s+1$</span> to <span>$I$</span>. These distributions are</p><div>\[A: \frac{p_1}{P_s}, \frac{p_2}{P_s}, \ldots, \frac{p_s}{P_s}
\quad \text{and} \quad
B: \frac{p_{s+1}}{1-P_s}, \ldots, \frac{p_n}{1-P_s}
\quad \text{where} \quad
P_s = \sum_{i=1}^{s}p_i.\]</div><p>The entropic correlations associated with each distribution are</p><div>\[C(A) = -\ln \sum_{i=1}^{s} \left( \frac{p_i}{P_s} \right)^2 \quad \text{and} \quad C(B) = -\ln \sum_{i=s+1}^{I} \left( \frac{p_i}{1 - P_s} \right)^2.\]</div><p>Combining these two entropic correlation functions we have</p><div>\[\psi(s) = -\ln \sum_{i=1}^{s} \left( \frac{p_i}{P_s} \right)^2 -\ln \sum_{i=s+1}^{I} \left( \frac{p_i}{1 - P_s} \right)^2.\]</div><p>Finding the discrete value <span>$s$</span> which maximises the function <span>$\psi(s)$</span> produces the sought-after threshold value (i.e. the bin which determines the threshold).</p><p><strong>Arguments</strong></p><p>The function argument is described in more detail below.</p><p><strong><code>img::AbstractArray</code></strong></p><p>The image that needs to be binarized. The image is automatically converted to <code>Gray</code> in order to construct the requisite graylevel histogram.</p><p><strong>Example</strong></p><p>Binarize the &quot;cameraman&quot; image in the <code>TestImages</code> package.</p><pre><code class="language-julia">using TestImages, ImageBinarization

img = testimage(&quot;cameraman&quot;)
img_binary = binarize(img, Yen())</code></pre><p><strong>Reference</strong></p><ol><li>Yen JC, Chang FJ, Chang S (1995), “A New Criterion for Automatic Multilevel Thresholding”, IEEE Trans. on Image Processing 4 (3): 370-378, <a href="https://doi.org/10.1109/83.366472">doi:10.1109/83.366472</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/baa797713364592e22dd44d3e4952175db34cd69/src/algorithms/yen.jl#L1-L73">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
