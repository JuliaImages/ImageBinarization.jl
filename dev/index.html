<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ImageBinarization.jl Documentation · Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>ImageBinarization.jl Documentation</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>ImageBinarization.jl Documentation</a></li></ul><a class="edit-page" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>ImageBinarization.jl Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="ImageBinarization.jl-Documentation-1" href="#ImageBinarization.jl-Documentation-1">ImageBinarization.jl Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.binarize-Tuple{Otsu,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}" href="#ImageBinarization.binarize-Tuple{Otsu,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}"><code>ImageBinarization.binarize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">imgb = binarize(Otsu(), img)
binarize!(Otsu(), img)</code></pre><p>Under the assumption that the histogram is bimodal the threshold is set so that the resultant inter-class variance is maximal.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>img</code></strong></p><p>An <code>AbstractGray</code> image which is to be binarized into background (<code>Gray(0)</code>) and foreground (<code>Gray(1)</code>) pixels.</p><p><strong>Reference</strong></p><p>Nobuyuki Otsu (1979). &quot;A threshold selection method from gray-level histograms&quot;. <em>IEEE Trans. Sys., Man., Cyber.</em> 9 (1): 62–66. <a href="http://dx.doi.org/doi:10.1109/TSMC.1979.4310076">doi:10.1109/TSMC.1979.4310076</a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/f72ef817c69adaed78762dfee7704223a0da207f/src/otsu.jl#L1-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.binarize-Tuple{Polysegment,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}" href="#ImageBinarization.binarize-Tuple{Polysegment,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}"><code>ImageBinarization.binarize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">imgb = binarize(Polysegment(), img)
binarize!(Polysegment(), img)</code></pre><p>Uses the <em>polynomial segmentation</em> technique to group the image pixels into two categories (foreground and background).</p><p><strong>Details</strong></p><p>The approach involves constructing a univariate second-degree polynomial such that the two roots of the polynomial represent the graylevels of two cluster centers (i.e the foreground and background). Pixels are then assigned to the foreground or background depending on which cluster center is closest.</p><p><strong>Arguments</strong></p><p>The function arguments are described in more detail below.</p><p><strong><code>img</code></strong></p><p>An <code>AbstractGray</code> image which is to be binarized into background (<code>Gray(0)</code>) and foreground (<code>Gray(1)</code>) pixels.</p><p><strong>Reference</strong></p><p>[1] R. E. Vidal, &quot;Generalized Principal Component Analysis (GPCA): An Algebraic Geometric Approach to Subspace Clustering and Motion Segmentation.&quot; Order No. 3121739, University of California, Berkeley, Ann Arbor, 2003.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/f72ef817c69adaed78762dfee7704223a0da207f/src/polysegment.jl#L1-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.binarize!-Tuple{Otsu,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}" href="#ImageBinarization.binarize!-Tuple{Otsu,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}"><code>ImageBinarization.binarize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = binarize!(Otsu(), img)</code></pre><p>Same as <a href="#ImageBinarization.binarize-Tuple{Otsu,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}"><code>binarize</code></a> except that it modifies the image that was passed as an argument.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/f72ef817c69adaed78762dfee7704223a0da207f/src/otsu.jl#L28-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageBinarization.binarize!-Tuple{Polysegment,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}" href="#ImageBinarization.binarize!-Tuple{Polysegment,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}"><code>ImageBinarization.binarize!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">t = binarize!(Polysegment(), img)</code></pre><p>Same as <a href="#ImageBinarization.binarize-Tuple{Polysegment,AbstractArray{#s1,2} where #s1&lt;:(Color{T,1} where T)}"><code>binarize</code></a> except that it modifies the image that was passed as an argument.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageBinarization.jl/blob/f72ef817c69adaed78762dfee7704223a0da207f/src/polysegment.jl#L35-L40">source</a></section><footer><hr/></footer></article></body></html>
